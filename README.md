# 선물 추천 챗봇 PresenTALK 개발기

 안녕하세요. 챗봇을 직접 개발하면서 있었던 일들과 느꼈던 부분을 자유로운 형식의 글로 작성해보려고 합니다. 제가 이 글을 쓰는 이유는 지금까지 개발을 하면서 많은 분들이 작성한 글이나 포스팅을 보면서 많은 도움을 받아서, 저도 언젠가 도움이 되는 내용이 있으면 꼭 공유를 해보자고 항상 생각했기 때문입니다. 그리고 뭔가 글을 잘 쓰는, 인문학적 소양을 갖춘 다재다능한 개발자의 모습을 스스로 원했던 것 같은데... 4줄 밖에 안썼는데 안될 것 같습니다. 그래도 일단 시작해보겠습니다. ( 혹시라도 글을 보시면서 궁금하신 부분이 있으시다면 mu0gum@naver.com 으로 메일 주시면 제가 아는 범위 내에서 대답해 드리도록 하겠습니다. )
 
 ( 앞으로 작성할 내용은 전문적인 자연어 처리나 딥러닝, 프로그래밍에 대한 특별한 기술에 대해 다루지 않습니다. 다룰 수가 없습니다. ~몰라요..~ 그래도 작성한 소스코드는 같이 올릴 예정입니다. 솔직히 부끄러워서 소스코드는 올리지 않으려고 했는데 그러면 이 글을 작성하는 의미가 없는 것 같아 같이 올립니다. 저는 이제 4년차 개발자이고, 파이썬을 해본적이 없고, 퇴근 후에 시간을 쪼개서 코딩을 했고, 코딩을 원래 잘 못하기 때문에.. 제가 작성한 파이썬 코드가 훌륭할거라 생각하지 않습니다. 대신 많은 분들(?)의 질타를 받고 성장하고 싶은 욕심은 많으니 이상한 부분이나 개선 가능한 부분에 대해서 피드백 주시면 정말 감사할 것 같습니다! )
 
 
 ## 왜 챗봇을 만들게 되었는가?
 서론을 제외한 첫 주제이기 때문에 최대한 멋있는 내용을 생각해보려고 했는데, 실은 별다른 이유가 없는 것 같습니다. 굳이 표현하자면 **"사람의 말에 적절한 응답을 하는 프로그램을 만드는 모습이 멋있을 것 같아서"** 입니다. 뭐 사고가 거기에 미치기까지 알파고와 이세돌에 대한 다큐멘터리를 우연히 본 것 부터 시작해야 하지만, TMI 기 때문에 생략하겠습니다. 그래도 "사람의 말을 이해하는 프로그램" 이라는 것 자체가 개발자인 저에게 매우 흥미로운 주제로 다가왔기 때문에 꼭 도전해보고 싶었습니다. 관련 내용을 리서치 하면서 자연어처리가 어떻고, 딥러닝이 어떻고, Word2Vec 이 어떻고 하는 여러 어려워 보이는 내용들이 많았지만 일단 도전해보자! 라고 생각되서 챗봇을 만들게 되었습니다.
 
 
## 어떤 기능을 하는 챗봇을 만들 것인가?
 저는 4년 전쯤? KTDS에서 국비 지원 교육을 받았습니다. 교육을 받으면서 "사연을 입력받아 선물을 추천해주는 웹어플리케이션" 을 주제로 개발을 했는데, 그 때 주제가 마음에 들어서 나중에 꼭 다시 멋지게 만들어 보자고 다짐 했습니다. 어떤 주제로 챗봇을 만들까 고민하던 차에 그 때 생각이 났고 "필요한 내용을 물어보고 선물을 추천해주는 챗봇" 을 만들게 되었습니다.
 

## 프로젝트의 시작
 본론으로 들어가지 않고 불필요한 이야기만 하는 것 같지만 개발기니까 일단 계속 가겠습니다. 급하신 분들은 [1. 챗봇 구조](https://github.com/mu0gum/nlp_research/blob/master/README.md#1-챗봇-구조) 부터 보시면 될 것 같습니다. 이야기를 계속하자면 저는 일단 이건 혼자서 할 수 없다고 판단을 내리고 같이 할 팀원을 구하기 시작했습니다. 같이 교육을 받았던 친구들 중에 관심을 보인 두 친구에게 같이 할 것을 제안했습니다. 그 중 한 친구가 피피티로 만들어서 브리핑을 하라길래 또 열심히 만들어서 보고를 드렸습니다. 정성에 감동한 덕분인지 결국 세명이서 챗봇 개발 / 추천알고리즘 개발 / 웹, 앱 개발 3 파트로 나누어서 프로젝트를 진행하게 되었습니다. ( 같이 해준다고 했을 때 정말 고마웠습니다ㅠㅠ ) 저는 제 관심사인 챗봇 개발을 진행하고 있고, 다른 친구들이 나머지 부분을 맡아서 진행하고 있습니다. 아직 현재 진행형입니다. 현재 진행형임에도 글을 쓰는 이유는 모든 내용을 금방 쓸 것 같지도 않고, 계속 미루다보면 결국에는 쓰지 못할 것 같아서입니다. 크게 욕심내지 않고 조금씩 작성해 나가도록 하겠습니다. 아래는 제가 작성했던 PPT 의 일부분입니다. 겁나 쉽게 생각했던 것 같네요..오글거리기도 하고..


 <p align="center">
    <image src="https://github.com/mu0gum/nlp_research/blob/master/images/PT_%EA%B8%B0%ED%9A%8D1.png" width="500">
    <image src="https://github.com/mu0gum/nlp_research/blob/master/images/PT_%EA%B8%B0%ED%9A%8D2.png" width="500">
 
 
## 1. 챗봇 구조
 지금은 챗봇을 만든지 시간이 좀 지나서 어느정도 틀이 잡혔지만 처음에는 어떻게 챗봇을 만들어야하나 막막했습니다. 그 때 처음 많이 도움을 받았던 사이트가 바로 이곳입니다.
 
 https://exagen.tistory.com/notice/63
 
 
챗봇이 무엇이고, 어떻게 기능이 동작되어야 할지에 대해 개념을 잡는데 많은 도움이 되었습니다. 제가 앞으로 링크를 남기는 사이트들은 서론에 밝혔듯 언젠간 도움이 되는 포스팅을 작성해야겠다고 마음먹게 만들어 준 사이트들일겁니다. 이미 방문해본 곳일수도 있지만 아니라면 꼭 방문해 보시길 바랍니다. 저의 글은 말 그대로 개발기기 때문에 경험에 가깝고, 제가 링크를 남긴 사이트들은 학습에 도움이 될거라고 생각합니다.

다시 본론으로 들어가서 제가 만든 챗봇의 구조는 아래와 같습니다. 


 <p align="center">
     <image src="https://github.com/mu0gum/nlp_research/blob/master/images/PresenTALK_%EC%B1%97%EB%B4%87%EA%B5%AC%EC%A1%B0_20190301(%EC%88%98%EC%A0%95).png" width="600">


모든 로직을 플로우차트로 표현할 수 없어서 간략하게만 작성해 보았습니다. 위의 플로우 차트에서 중요한 부분은 **"의도 분류", "이전 대화 분석"** 입니다. 제가 생각했을 때, 챗봇 기능을 구현하는데 있어서 가장 중요한 부분은 상대방의 의도를 파악하는 부분이었습니다. 이 부분에 대한 용어는 화행분석, 의도분류 등 다양한 용어로 불리는 것 같은데, 일단 제가 참고한 분은 의도 분류 Task 라고 되어있기 때문에 저도 **의도 분류**로 작성하도록 하겠습니다. 


솔직히 선물을 추천해주는 챗봇 ( 특정 기능만을 수행하는 ) 을 만드는데 단순히 잘 짜여진 시나리오와 패턴 매칭으로도 가능할 것 같았지만 욕심많은 개발자인 저는 선물을 추천해주는 것 외에도 질문에 대한 응답, 명령에 대한 수행을 미약하게나마 할 수 있는 범용성을 가진 챗봇을 구현하고 싶었습니다. 그래서 의도 분류가 꼭 필요했습니다. 그림에 대한 설명을 계속하자면 일단 사용자가 입력한 텍스트를 의도 분류를 진행합니다. 상대방의 의도가 "Qestion" 이라면, 텍스트를 분석해서 쿼리를 만들고, 미리 구축해 놓은 지식그래프( Knowledge graph ) 에 쿼리를 날립니다. ( 자세한 내용은 추후에 다루겠습니다. ) 검색 결과가 있다면 결과를 응답해주고, 없다면 패턴 매칭 룰에 매칭 되는 것이 있나 찾아보고, 또 없다면 얼버무리거나 모른다고 응답합니다. 

***
여기서 잠깐 패턴 매칭에 대해서 간략하게 이야기하고 넘어가겠습니다. 패턴 매칭에 대한 설명은 위에 링크에 자세히 있지만 제가 구현한 방법도 간략히 설명
드리도록 하겠습니다. ( 패턴 매칭 룰은 초기에 작성한 로직이라 개선해야 할 부분이 많습니다. 처음 계획했던 코딩에서 변경이 많기 때문에 같이 변경 되었어야 하는데, 이것저것 할 것이 많아서 못하고 있었습니다. 개선이 되면 추가하도록 하겠습니다. )


일단 패턴 매칭을 하기 위한 DB Table 구조를 아래와 같이 만들었습니다.


 <p align="center">
    <image src="https://github.com/mu0gum/nlp_research/blob/master/images/matching_rule.PNG" width="700">


처음 계획은 Chatscript 를 따라해서 defined_rule 을 입력 받으면, 정규식 처리를 위한 matching_rule 을 자동으로 만들어서 입력하려고 했는데, 제가 챗봇 기능 자체를 서비스하는게 아니기 때문에 그냥 matching_rule 을 직접 입력해서 관리하고 있습니다. 어떻게보면 defined_rule 은 당장 필요없는 컬럼입니다. 어쨌든 matching_rule 에 있는 정규식 표현과 일치하면 response_rule 에 있는 메시지를 응답할 수 있도록 테이블을 구성했다고 생각하시면 될 것 같습니다.

```python
# 정의해 놓은 Rule 에서 매칭이 되는 부분을 찾음
def find_matching_rule(self, message):
	noun_list = self.mecab.nouns(message)

	# 추출된 명사가 topic_list 에 존재하는지 확인
	topic = ''
	for topic_row in self.topic_list:
		for noun in noun_list:
			if noun == topic_row['topic_name']:
				if topic_row['topic_owner'] == 'N':
					topic = topic_row['topic_id']
				else:
					topic = topic_row['topic_owner']

	# topic 을 찾지 못한 경우 -> 모든 경우 rule search
	if topic == '':
		matching_rule_list = self.all_rule_list
	else:
		matching_rule_list = self.rule_list[topic]

	response_text = []
	for rule in matching_rule_list:
		matching_rule = rule['matching_rule']
		compiled_rule = re.compile(matching_rule)

		if compiled_rule.match(message):
			response_text.append(rule['response_rule'])
			break

	return response_text
```

패턴 매칭을 하는 function 은 위와 같습니다. 간단히 설명하면 사용자가 입력한 텍스트에서 형태소 분석을 통해 명사들을 추출합니다. 그 명사들이 rule 에 정의되어 있는 topic 과 일치하면 그 topic 에 있는 rule_list 만 가지고 와서 패턴 매칭을 진행하고 그렇지 않다면 모든 룰을 바탕으로 패턴 매칭을 진행합니다. 
***

패턴 매칭에 대한 설명은 이정도로 하고 구조에 설명을 이어가겠습니다. 위의 플로우차트에서 의도가 "Command" 인 경우에는 명령을 분석합니다. 명령을 분석한 후 챗봇에서 처리할 수 있는 명령인 경우에는 그 명령에 따른 적절한 응답을 진행합니다. 만약 수행할 수 없는 명령이라면 패턴 매칭을 진행하고, 매칭되는 부분이 없다면 얼버무립니다.


의도 분류가 "Question", "Command" 가 아닌 경우에는 이전에 챗봇이 응답한 Message Type 을 바탕으로 로직을 전개해 나갑니다. 이 Message Type 이 위에서 말씀드린 **"이전 대화 분석"** 의 key 입니다. 제가 정의한 Message Type 은 아래와 같습니다.


+ BG : Bot Greeting
+ BS : Bot Starting
+ BF : Bot Feature
+ BN : Bot Normal
+ BR : Bot Recommand
+ BA : Bot Answer


아직 확정은 아니고 언제든지 추가될 수 있고, 삭제가 될 수 있습니다. 제가 Message Type 을 정의한 이유는 아래 처럼 활용하기 위함입니다.


 <p align="center">
    <image src="https://github.com/mu0gum/nlp_research/blob/master/images/PresenTALK_Sample.PNG" width="300">
     

***
사용자가 채팅방에 입장하게 되면, 챗봇은 인사를 하면서 사용자를 맞이(BG) 합니다. => 사용자의 다음 입력 text 가 "Question" 이나 "Command" 가 아니라면, 이전 챗봇의 Message Type 을 확인합니다. => 이전 Message Type 이 BG 기 때문에, 인사를 한 다음에는 선물 추천을 원하냐고(BS) 물어봅니다. => 사용자의 다음 입력 text 가 "Question" 이나 "Command" 가 아니라면, 이전 챗봇의 Message Type 을 확입합니다. => 이전 Message Type 이 BS 기 때문에 상대방의 응답이 긍정인지 부정인지 판단한 후, 긍정이라면 특징을 선물의 목적이나 대상에 대해 물어보고(BF) 부정이라면 정해진 로직을 수행합니다.
***


일단 현재까지 만든 챗봇의 구조는 이렇습니다. 아직 부족한 부분이 많고 개선해야 할 부분이 많아 보입니다. 그래도 "의도 분류", "이전 대화 분석" 의 조합으로 완벽하지는 않지만 선물을 추천해주는 기능에 간단한 질문이나 명령에 대한 응답은 가능합니다. 


일단 챗봇 구조에 대한 설명은 이정도에서 마치고 다음부터는 각 부분부분에 대해 중요하다고 생각되는 부분에 대해 설명하도록 하겠습니다.
챗봇 소스는 https://github.com/mu0gum/nlp_research/blob/master/presentalk/presentalkbot_v3.py 를 참고해주세요. **제가 파이썬에 대해 잘 몰라서 수정이 필요하다고 보이거나 개선사항이 보이면 꼭 좀 말씀 부탁드립니다! 가르침을 나누어주세요!**


## 2. 의도 분류
위에 있는 챗봇 구조 그림을 보게되면, 사용자가 텍스트를 입력하면 제일 먼저 하는 일은 상대방의 의도 분류입니다. 시나리오 기반으로만 챗봇을 만든다고 하면 의도 분류가 필수가 아닐수도 있지만, 욕심많은 개발자답게 일단 의도 분류를 추가해서 좀 더 범용성을 갖춘 챗봇을 만들기로 하고 조사를 시작했습니다. 자연어 처리나 머신러닝/딥러닝에 대한 개념이 전무했어서, 어떻게 구현을 해야하나 많이 찾아봤던 것 같습니다. 그 때 도움이 되었던 논문이 ["다양한 어휘 자질의 워드 임베딩을 이용한 화행 분석 추출](http://library.sogang.ac.kr/search/detail/SATSAD000000831041?mainLink=/search/sad&briefLink=/search/sad/result?q=%EC%84%9C%EA%B0%95%EB%8C%80%ED%95%99%EA%B5%90+%EC%9D%BC%EB%B0%98%EB%8C%80%ED%95%99%EC%9B%90_A_bk_1=jttjkorjttj_A_bk_0=jttjtjttj_A_st=FRNT_A_bk_3=jttj2016jttj_A_si=3_A_pn=4)" 입니다. 위 논문에서는 "의도 분류" 라는 용어 대신에 "화행 분석" 이라는 용어를 사용하고 있습니다. 동일한 의미이기 때문에 이해하시는데 크게 문제될 부분은 없을 것 같습니다. 논문을 보면서 규칙 기반의 모델을 개발하기에는 언어에 대한 이해도가 낮다는 문제점이 있었고, 딥러닝 기반의 모델은 학습을 위한 데이터가 없다는 문제점이 있었습니다. 분류를 위해서는 labeled data 가 필요했는데, 대화 자체는 영화의 자막이나 [국립국어원의 말뭉치 데이터](https://ithub.korean.go.kr/user/guide/corpus/guide1.do) 를 활용할 수 있지만 각 문장이 어떤 의도를 나타내는지에 대한 데이터는 없었기 때문에 논문에서 제시한 모델을 사용하기에 어려움이 있었습니다. 그 때 가뭄의 단비처럼 나타난 참고 자료가 바로 이곳 (https://github.com/warnikchow/dlk2nlp) 입니다. 여기에는 의도 분류를 위한 여러가지 모델의 대한 설명과 함께 labeled data set 이 함께 올라와 있습니다. 뜬금없는 이야기지만 위 논문도 그렇고 지금 소개하는 깃허브도 그렇지만 정말 고마운 분들이 많은 것 같습니다. ( 자신의 지식을 나누고 공유해주시는 모든 분들을 리스펙합니다ㅎㅎ ) 제가 개발한 챗봇도 위의 블로그의 CNN 기반의 모델을 바탕으로 intent_analyzer 를 개발하였습니다. 의도 분류를 위한 코딩은 위의 깃허브 주소를 참고하셔서 개발하시는 게 훨씬 도움이 될 것 같아 따로 소스코드는 첨부하지 않겠습니다. 다만 저의 모델을 검증해본 결과 accuracy 가 0.85 정도가 나왔기 때문에, 정확도를 조금이라도 높이고자 규칙을 베이스로 한 로직 ( 질문 Case )을 추가해주었습니다.


```python
def check_question(self, pos_result):
	pos_len = len(pos_result)

	# 판단하지 않음
	if pos_len < 3:
		return False

	last_pos = pos_result[pos_len-3:]
	if last_pos[2][0] != '?':
		return False
	two_pos = last_pos[0][1] + '+' + last_pos[1][1]
	if two_pos in ['EP+EF', 'NP+VCP+EF']:
		return True
	else:
		return False
```


위의 로직에 대해 간략히 설명하겠습니다. 제가 사용하는 mecab 형태소 분석기로 질문 형식의 문장을 형태소 분석을 진행해보면 아래와 같이 나오게 됩니다.


***

[('밥', 'NNG'), ('먹', 'VV'), ('었', 'EP'), ('니', 'EF'), ('?', 'SF')]

[('밥', 'NNG'), ('먹', 'VV'), ('었', 'EP'), ('어', 'EF'), ('?', 'SF')]

[('밥', 'NNG'), ('먹', 'VV'), ('었', 'EP'), ('습니까', 'EF'), ('?', 'SF')]

[('아이유', 'IC'), ('생일', 'NNG'), ('이', 'JKS'), ('언제', 'NP'), ('야', 'VCP+EF'), ('?', 'SF')]

[('아이유', 'IC'), ('고향', 'NNG'), ('이', 'JKS'), ('어디', 'NP'), ('야', 'VCP+EF'), ('?', 'SF')]

[('아이유', 'IC'), ('별명', 'NNG'), ('이', 'JKS'), ('뭐', 'NP'), ('야', 'VCP+EF'), ('?', 'SF')]

[('작년', 'NNG'), ('EPL', 'SL'), ('우승', 'NNG'), ('팀', 'NNG'), ('이', 'JKS'), ('어디', 'NP'), ('야', 'VCP+EF'), ('?', 'SF')]

[('작년', 'NNG'), ('EPL', 'SL'), ('우승', 'NNG'), ('팀', 'NNG'), ('이', 'JKS'), ('어디', 'NP'), ('니', 'VCP+EF'), ('?', 'SF')]

[('작년', 'NNG'), ('EPL', 'SL'), ('우승', 'NNG'), ('팀', 'NNG'), ('이', 'JKS'), ('어디', 'NP'), ('지', 'VCP+EF'), ('?', 'SF')]

[('제일', 'MAG'), ('좋', 'VA'), ('아', 'EC'), ('하', 'VV'), ('는', 'ETM'), ('축구', 'NNG'), ('선수', 'NNG'), ('는', 'JX'), ('?', 'SF')]

[('제일', 'MAG'), ('좋', 'VA'), ('아', 'EC'), ('하', 'VV'), ('는', 'ETM'), ('축구', 'NNG'), ('선수', 'NNG'), ('는', 'JX'), ('누구', 'NP'), ('입니까', 'VCP+EF'), ('?', 'SF')]

***


완벽하지는 않지만 위의 코딩에서 보이는 제가 만든 규칙은


1. 형태소 분석 결과에서 뒤에서 3개 까지 추출한다.
2. 해당 문장이 **질문**이기 위해서는 형태소 분석 결과의 **맨 마지막은 물음표(?)** 이어야 한다.
3. 맨 뒤 형태소를 제외한 두 형태소 분석의 결과의 합이 **'EP+EF' or 'NP+VCP+EF' 조합**이어야 한다.

입니다. 아직 개선을 할 부분으로는


1. 물음표 뒤에 올 수 있는 다양한 문자들에 대한 처리 ex) 밥 먹었니?^^ㅋㅋㅋㅋ
2. 형태소 분석기의 정확도
3. 빈약한 case 검증 ( 위에서 자세히 보면 NNG + JX 에 대한 처리는 되어있지 않습니다. )

등이 있습니다. 하지만 위의 로직만으로 의도 분류를 하는 것이 아니고, 조금이라도 정확도를 높여보고자 함께 사용되는 로직이기 때문에 일단 눈감고 넘어가도록 하겠습니다. ( 욕심이 많아 이것저것 벌려 놓기는 했는데, 각 기능에 구현은 기본적인 부분을 진행하고 개선시켜 나갈 계획입니다. ) 의도 분류는 제가 아는 내용이 많이 없어서 간단하게 쓰려고 했는데 조금 길어진 것 같습니다. 다음은 범용성을 위한 기능 중 하나인 **지식 그래프 탐색** 에 대해 작성하도록 하겠습니다.



